<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BlazePose Web2</title>
  <style>
    body {
      text-align: center;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
                     'Apple Color Emoji', 'Segoe UI Emoji', Arial, sans-serif;
      font-size: 16px;
      color: #111;
      background-color: #fff;
      margin: 0;
      padding: 0;
    }

    #container {
      position: relative;
      display: inline-block;
      margin: 0 auto;
      border: 2px dashed #ccc;
    }

    video, canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
    }

    canvas {
      z-index: 1;
    }

    #controls {
      margin-top: 10px;
    }

    button {
      margin: 10px;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
    }
    <button onclick="toggleCamera()">üì∑ Ïπ¥Î©îÎùº Ï†ÑÌôò</button>

  </style>
</head>
<body>
  <h2> Realtime pose5</h2>

  <div id="container">
    <video id="video" autoplay muted playsinline></video>
    <canvas id="canvas"></canvas>
  </div>
  <div style="margin-bottom: 10px;">
    <label for="username">Name: </label>
    <input type="text" id="username" placeholder="John" style="font-size: 16px; padding: 5px;">
  </div>

  <div id="controls">
    <button onclick="startRecording()">üî¥ Start</button>
    <button onclick="stopRecording()">‚èπÔ∏è End</button>
  </div>
  <div id="status" style="margin-top: 10px; font-weight: bold; font-size: 16px;"></div>

  <!-- TensorFlow + BlazePose -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let recording = false;
    let csvData = [];

    const keypointNames = [
      "nose",              // 0
     // null, null, null,    // 1-3 left eye
     // null, null, null,    // 4-6 right eye
      "left_ear",          // 7
      "right_ear",         // 8
     // null, null,          // 9-10 mouth
      "left_shoulder",     // 11
      "right_shoulder",    // 12
      "left_elbow",        // 13
      "right_elbow",       // 14
      "left_wrist",        // 15
      "right_wrist",       // 16
      //null, null,          // 17-18 pinky
      "left_index",        // 19
     // null,                // 20 (right_index Ï†úÏô∏)
      //null,                // 21 (left_thumb Ï†úÏô∏)
      "right_thumb",       // 22
      "left_hip",          // 23
      "right_hip",         // 24
      "left_knee",         // 25
      "right_knee",        // 26
      "left_ankle",        // 27
      "right_ankle",       // 28
      "left_heel",         // 29
      "right_heel",        // 30
      "left_foot_index",   // 31
      "right_foot_index",  // 32
      "bodyCenter",        // 33
      "forehead",          // 34
      "leftThumb",         // 35
      "leftHand",          // 36
      "rightThumb",        // 37
      "rightHand"          // 38
    ];

    const skeletonEdges = [
      // torso
      [0, 1], [1, 2], [2, 0], // head
      [3, 4], // left_shoulder ‚Üí right_shoulder
      [3, 11], // left_shoulder ‚Üí left_hip
      [4, 12], // right_shoulder ‚Üí right_hip
      [11, 12], // left_hip ‚Üí right_hip
    
      // left arm
      [3, 5],  // left_shoulder ‚Üí left_elbow
      [5, 7],  // left_elbow ‚Üí left_wrist
      [7, 9],  // left_wrist ‚Üí left_index
      [7, 23], // left_wrist ‚Üí leftThumb
      [7, 24], // left_wrist ‚Üí leftHand
    
      // right arm
      [4, 6],  // right_shoulder ‚Üí right_elbow
      [6, 8],  // right_elbow ‚Üí right_wrist
      [8, 10], // right_wrist ‚Üí right_index
      [8, 25], // right_wrist ‚Üí rightThumb
      [8, 26], // right_wrist ‚Üí rightHand
    
      // left leg
      [11, 13], // left_hip ‚Üí left_knee
      [13, 15], // left_knee ‚Üí left_ankle
      [15, 17], // left_ankle ‚Üí left_heel
      [17, 19], // left_heel ‚Üí left_foot_index
    
      // right leg
      [12, 14], // right_hip ‚Üí right_knee
      [14, 16], // right_knee ‚Üí right_ankle
      [16, 18], // right_ankle ‚Üí right_heel
      [18, 20], // right_heel ‚Üí right_foot_index
    
      // center
      [0, 21],  // nose ‚Üí bodyCenter
      [21, 11], // bodyCenter ‚Üí left_hip
      [21, 12], // bodyCenter ‚Üí right_hip
      [0, 22]   // nose ‚Üí forehead
    ];

    let currentFacingMode = 'user'; // Í∏∞Î≥∏Í∞í: Ï†ÑÎ©¥ Ïπ¥Î©îÎùº
    
    async function setupCamera(facingMode = 'user') {
      // Í∏∞Ï°¥ Ïä§Ìä∏Î¶º Ï†ïÏßÄ
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(track => track.stop());
      }
    
      // ÏÉà Ïä§Ìä∏Î¶º ÏöîÏ≤≠
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: facingMode }
      });
    
      video.srcObject = stream;
    
      // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î°úÎìú ÌõÑ ÌÅ¨Í∏∞ ÏÑ§Ï†ï
      return new Promise(resolve => {
        video.onloadedmetadata = () => {
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          video.width = video.videoWidth;
          video.height = video.videoHeight;
          document.getElementById('container').style.width = video.videoWidth + 'px';
          document.getElementById('container').style.height = video.videoHeight + 'px';
          resolve();
        };
      });
    }

    async function toggleCamera() {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const videoInputs = devices.filter(d => d.kind === 'videoinput');
    
      if (videoInputs.length < 2) {
        alert("üîÅ Ï†ÑÌôò Í∞ÄÎä•Ìïú Ïπ¥Î©îÎùºÍ∞Ä ÌïòÎÇòÎøêÏûÖÎãàÎã§.");
        return;
      }
    
      currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
      await setupCamera(currentFacingMode);
    }


    async function main() {
      await setupCamera(currentFacingMode);


      const w = video.videoWidth;
      const h = video.videoHeight;
      canvas.width = w;
      canvas.height = h;
      
      video.width = w;
      video.height = h;
      const container = document.getElementById('container');
      container.style.width = w + 'px';
      container.style.height = h + 'px';
      const detector = await poseDetection.createDetector(poseDetection.SupportedModels.BlazePose, {
        runtime: 'mediapipe',
        solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/pose',
        modelType: 'lite'
      });
      const isMobile = /Android|iPhone/i.test(navigator.userAgent);
      const shouldFlip = !isMobile;
      

      const render = async () => {
        const poses = await detector.estimatePoses(video);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        if (poses.length > 0 && poses[0].keypoints) {
          const excludeIndices = [1, 2, 3, 4, 5, 6, 9, 10, 17, 18, 21, 22];
          const keypoints = poses[0].keypoints;
        
          // ‚úÖ ÌïÑÏöîÌïú Ìè¨Ïù∏Ìä∏Îßå ÌïÑÌÑ∞ÎßÅ (ÏàúÏÑú Ïú†ÏßÄ)
          const filteredKeypoints = keypoints.filter((_, i) => !excludeIndices.includes(i));
        
          // üî¥ Ï†ê + Ïù¥Î¶Ñ
          filteredKeypoints.forEach((kp, i) => {
            if (kp.score > 0.4) {
              ctx.beginPath();
              ctx.arc(kp.x, kp.y, 5, 0, 2 * Math.PI);
              ctx.fillStyle = 'red';
              ctx.fill();
        
              ctx.font = '10px sans-serif';
              ctx.fillStyle = 'blue';
              ctx.fillText(keypointNames[i], kp.x + 6, kp.y + 6);
            }
          });
        
        
          // ü¶¥ ÏùºÎ∞ò Ïä§ÏºàÎ†àÌÜ§ Ïó∞Í≤∞
          skeletonEdges.forEach(([i, j]) => {
            const kp1 = filteredKeypoints[i];
            const kp2 = filteredKeypoints[j];

              // ‚úÖ ÏóêÎü¨ Î∞©ÏßÄ
            if (!kp1 || !kp2) return;
            
            if (kp1.score > 0.4 && kp2.score > 0.4) {
              ctx.beginPath();
              ctx.moveTo(kp1.x, kp1.y);
              ctx.lineTo(kp2.x, kp2.y);
              ctx.strokeStyle = 'lime';
              ctx.lineWidth = 2;
              ctx.stroke();
            }
          });
        
          // ‚è∫Ô∏è CSV Ï†ÄÏû•
          if (recording) {
            const row = filteredKeypoints.flatMap(kp => [kp.x, kp.y, kp.score]);
            csvData.push(row);
          }
        }

      
        ctx.restore();
        requestAnimationFrame(render);
      };

      render();
    }

    function startRecording() {
      recording = true;
      csvData = [];
      
      const status = document.getElementById('status');
      status.innerText = 'üì° Î†àÏΩîÎî© Ï§ë...';
      status.style.color = 'red';
    }

    
    function stopRecording() {
      recording = false;

      // ÏÉÅÌÉú ÌëúÏãú ÏßÄÏö∞Í∏∞
      const status = document.getElementById('status');
      status.innerText = '';

      // üìå ÏÇ¨Ïö©Ïûê Ïù¥Î¶Ñ Í∞ÄÏ†∏Ïò§Í∏∞
      const username = document.getElementById('username').value.trim() || 'unknown';

      // ‚è∞ ÌòÑÏû¨ ÏãúÍ∞Ñ Î¨∏ÏûêÏó¥ ÏÉùÏÑ± (YYYY-MM-DD-HH-MM)
      const now = new Date();
      const yyyy = now.getFullYear();
      const mm = String(now.getMonth() + 1).padStart(2, '0');
      const dd = String(now.getDate()).padStart(2, '0');
      const hh = String(now.getHours()).padStart(2, '0');
      const min = String(now.getMinutes()).padStart(2, '0');
      const timestamp = `${yyyy}-${mm}-${dd}-${hh}-${min}`;

      // üìÅ ÌååÏùºÎ™Ö ÏÉùÏÑ±
      const filename = `${username}_${timestamp}.csv`;

      // üìÑ CSV ÏÉùÏÑ±
      let header = [];
      keypointNames.forEach((name, i) => {
        if (!excludeIndices.includes(i)) {
          header.push(`${name}_x`, `${name}_y`, `${name}_score`);
        }
      });
      
      let csvContent = [header.join(',')];
      csvData.forEach(row => {
        csvContent.push(row.join(','));
      });
      
      const blob = new Blob([csvContent.join('\n')], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
    }


    main();
  </script>
</body>
</html>
